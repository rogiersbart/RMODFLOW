% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{rmf_interpolate}
\alias{rmf_interpolate}
\alias{rmf_interpolate.rmf_2d_array}
\alias{rmf_interpolate.rmf_3d_array}
\alias{rmf_interpolate.rmf_4d_array}
\title{Interpolation of points on a rmf_2d/3d/4d_array}
\usage{
rmf_interpolate(...)

\method{rmf_interpolate}{rmf_2d_array}(
  array,
  dis,
  xout,
  yout,
  obj = NULL,
  method = "linear",
  outside = "nearest",
  prj = rmf_get_prj(dis),
  mask = array * 0 + 1
)

\method{rmf_interpolate}{rmf_3d_array}(
  array,
  dis,
  xout,
  yout,
  zout,
  obj = NULL,
  method = "linear",
  outside = "nearest",
  prj = rmf_get_prj(dis),
  mask = array * 0 + 1
)

\method{rmf_interpolate}{rmf_4d_array}(
  array,
  dis,
  xout,
  yout,
  zout,
  tout,
  obj = NULL,
  method = "linear",
  outside = "nearest",
  time = "step",
  prj = rmf_get_prj(dis),
  mask = array(1, dim = dim(array)[1:3])
)
}
\arguments{
\item{array}{numeric rmf_2d/3d/4d_array}

\item{dis}{\code{RMODFLOW} dis object}

\item{xout}{x coordinates of points to interpolate to}

\item{yout}{y coordinates of points to interpolate to}

\item{obj}{sf or sfc point or multipoint object to obtain the point locations from. Overrides \code{xout}, \code{yout} and \code{zout}. Needs to be of XYZ dimension when array is 3d or 4d.}

\item{method}{interpolation method. Possible methods are 'nearest' for nearest-neighbor or 'linear' (default) for bi/trilinear interpolation.}

\item{outside}{'nearest' or 'drop'. Defines how interpolated points outside the convex hull described by the cell nodes should be handled for method = 'linear'. 'nearest' (default) sets the values equal to the nearest nodal value, 'drop' sets them to NA.}

\item{prj}{\code{RMODFLOW} prj object}

\item{mask}{a 2d array when \code{array} is 2d or a 3d array when \code{array} is 3d or 4d that can be coerced to logical. Used to set inactive cells to NA. Defaults to all cells active.}

\item{zout}{z coordinates of points to interpolate to when the array is 3d or 4d.}

\item{tout}{time instances to interpolate to when the array is 4d. Either as a fractional time step or as total simulated time, depending on the \code{time} argument.}

\item{time}{either 'step' (default) or 'totim'. Defines if \code{tout} is a time step fraction (i.e. index for the 4th dimension) or the absolute time. If \code{totim}, the array should have a totim attribute, e.g. as returned from \code{rmf_read_head}}
}
\value{
a vector with the interpolated values for each point.
}
\description{
Interpolation of points on a rmf_2d/3d/4d_array
}
\details{
Users must make sure that the projection of \code{xout}, \code{yout}, \code{zout} or \code{obj} are the same as the one described by the \code{prj} argument.
Function assumes the 2d array is not a cross-section. Consider using a 3d array if the vertical dimension is of any concern.
Extrapolation is not supported: values outside the grid are set to NA. Values inside the grid but outside the convex hull described by the cell nodes depend on the 'outside' argument when method = 'linear'.

Interpolation of a point on a 4d array is performed by 3d interpolation at the nearest time steps followed by a interpolation of the obtained values using the specified \code{method}.
}
\examples{
dis <- rmf_create_dis()
n <- 50
xout <- runif(n, min = -10, max = 1010)
yout <- runif(n, min = -10, max = 1010)
zout <- runif(n, min = -31, max = 1)

# 2d
array <- rmf_create_array(1:prod(dis$nrow, dis$ncol), dim = c(dis$nrow, dis$ncol))

rmf_interpolate(array, dis, xout, yout)
rmf_interpolate(array, dis, xout, yout, outside = 'drop')
rmf_interpolate(array, dis, xout, yout, method = 'nearest')

# 3d
array <- rmf_create_array(1:prod(dis$nrow, dis$ncol, dis$nlay), dim = c(dis$nrow, dis$ncol, dis$nlay))

rmf_interpolate(array, dis, xout, yout, zout, outside = 'drop')

pts <- sf::st_sfc(list(sf::st_point(c(150, 312, -12.5)), sf::st_point(c(500, 500, -22)), sf::st_point(c(850, 566, -16.3))))
rmf_interpolate(array, dis, obj = pts)

# 4d
array <- rmf_create_array(1:prod(dis$nrow, dis$ncol, dis$nlay, 4), dim = c(dis$nrow, dis$ncol, dis$nlay, 4))
attr(array, 'totim') <- c(100, 200, 500, 780)

tout <- runif(n, min = 0.85, max = 4.2) # tout as fractional time step
rmf_interpolate(array, dis, xout, yout, zout, tout)

tout <- runif(n, min = 90, max = 800) # tout as total time
rmf_interpolate(array, dis, xout, yout, zout, tout, time = 'totim')
 
}
